defmodule Ecto.ERD.Document do
  @moduledoc false
  alias Ecto.ERD.{Node, Field, Edge}
  defstruct [:edges, :nodes, :clusters]

  def map_nodes(%__MODULE__{nodes: nodes, edges: edges, clusters: []}, map_node_callback)
      when is_function(map_node_callback, 1) do
    {nodes, removed_nodes} =
      Enum.flat_map_reduce(nodes, [], fn node, removed_nodes ->
        case map_node_callback.(node) do
          nil -> {[], [node | removed_nodes]}
          node -> {[node], removed_nodes}
        end
      end)

    clusters = Enum.group_by(nodes, & &1.cluster)

    edges =
      Enum.reject(edges, fn edge ->
        Enum.any?(removed_nodes, fn node -> Edge.connected_with_node?(edge, node) end)
      end)

    {nodes, clusters} = Map.pop(clusters, nil)

    %__MODULE__{
      nodes: List.wrap(nodes),
      clusters: clusters,
      edges: edges
    }
  end

  def new(modules) do
    data =
      modules
      |> Enum.flat_map(fn module ->
        association_components =
          :associations
          |> module.__schema__()
          |> Enum.flat_map(fn assoc_field ->
            from_reflection(module.__schema__(:association, assoc_field))
          end)

        embed_components =
          :embeds
          |> module.__schema__()
          |> Enum.flat_map(fn embed_field ->
            from_reflection(module.__schema__(:embed, embed_field))
          end)

        [Node.from_schema_module(module) | embed_components ++ association_components]
      end)
      |> Enum.group_by(fn
        %Edge{} -> :edges
        %Node{} -> :nodes
      end)

    %__MODULE__{
      # multiple nodes could be generated by multiple schemas which use the same table in many to many relation
      nodes: Enum.uniq(Map.get(data, :nodes, [])),
      edges: merge_edges_with_same_direction(Map.get(data, :edges, [])),
      clusters: []
    }
  end

  defp merge_edges_with_same_direction(edges) do
    edges
    |> Enum.group_by(fn %Edge{from: from, to: to} -> {from, to} end)
    |> Enum.map(fn {_direction, edges} -> Enum.reduce(edges, &Edge.merge/2) end)
  end

  defp from_reflection(%Ecto.Embedded{} = embedded) do
    [
      Edge.new(%{
        from: {embedded.owner.__schema__(:source), embedded.owner, {:field, embedded.field}},
        to: {embedded.related.__schema__(:source), embedded.related, {:header, :schema_module}},
        assoc_types: [has: embedded.cardinality]
      })
    ]
  end

  defp from_reflection(%Ecto.Association.BelongsTo{
         owner: owner,
         owner_key: owner_key,
         related: related,
         related_key: related_key
       }) do
    related_source = related.__schema__(:source)
    owner_source = owner.__schema__(:source)

    [
      Edge.new(%{
        from: {related_source, related, {:field, related_key}},
        to: {owner_source, owner, {:field, owner_key}},
        assoc_types: [:belongs_to]
      })
    ]
  end

  defp from_reflection(%Ecto.Association.Has{
         owner: owner,
         owner_key: owner_key,
         related: related,
         related_key: related_key,
         cardinality: cardinality
       }) do
    related_source = related.__schema__(:source)
    owner_source = owner.__schema__(:source)

    [
      Edge.new(%{
        from: {owner_source, owner, {:field, owner_key}},
        to: {related_source, related, {:field, related_key}},
        assoc_types: [has: cardinality]
      })
    ]
  end

  defp from_reflection(%Ecto.Association.ManyToMany{
         join_through: join_through,
         owner: owner,
         related: related,
         join_keys: [{join_source_owner_fk, owner_pk}, {join_source_related_fk, related_pk}]
       }) do
    {join_module, join_source} =
      case join_through do
        value when is_atom(value) -> {value, value.__schema__(:source)}
        value when is_binary(value) -> {nil, value}
      end

    nodes =
      case join_module do
        nil ->
          fields = [
            Field.new(join_source_owner_fk, owner.__schema__(:type, owner_pk)),
            Field.new(join_source_related_fk, related.__schema__(:type, related_pk))
          ]

          [Node.from_schemaless_join_source(join_source, fields)]

        _join_module ->
          []
      end

    nodes ++
      [
        Edge.new(%{
          from: {owner.__schema__(:source), owner, {:field, owner_pk}},
          to: {join_source, join_module, {:field, join_source_owner_fk}},
          assoc_types: [has: :many]
        }),
        Edge.new(%{
          from: {related.__schema__(:source), related, {:field, related_pk}},
          to: {join_source, join_module, {:field, join_source_related_fk}},
          assoc_types: [has: :many]
        })
      ]
  end

  defp from_reflection(%Ecto.Association.HasThrough{}) do
    []
  end
end
